<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/MatAtBread/nodent#readme">nodent (v3.0.17)</a>
</h1>
<h4>NoDent - Asynchronous Javascript language extensions</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.nodent">module nodent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.nodent">
            function <span class="apidocSignatureSpan"></span>nodent
            <span class="apidocSignatureSpan">(initOpts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.EagerThenable">
            function <span class="apidocSignatureSpan">nodent.</span>EagerThenable
            <span class="apidocSignatureSpan">(tick)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.Thenable">
            function <span class="apidocSignatureSpan">nodent.</span>Thenable
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.asyncify">
            function <span class="apidocSignatureSpan">nodent.</span>asyncify
            <span class="apidocSignatureSpan">(promiseProvider)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.map">
            function <span class="apidocSignatureSpan">nodent.</span>map
            <span class="apidocSignatureSpan">(nodent, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.setCompileOptions">
            function <span class="apidocSignatureSpan">nodent.</span>setCompileOptions
            <span class="apidocSignatureSpan">(set, compiler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.setDefaultCompileOptions">
            function <span class="apidocSignatureSpan">nodent.</span>setDefaultCompileOptions
            <span class="apidocSignatureSpan">(compiler, env)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nodent.</span>Thenable.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nodent.</span>arboriculture</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nodent.</span>parser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nodent.</span>runtime</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nodent.Thenable">module nodent.Thenable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.Thenable.Thenable">
            function <span class="apidocSignatureSpan">nodent.</span>Thenable
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.Thenable.reject">
            function <span class="apidocSignatureSpan">nodent.Thenable.</span>reject
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.Thenable.resolve">
            function <span class="apidocSignatureSpan">nodent.Thenable.</span>resolve
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">nodent.Thenable.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nodent.Thenable.prototype">module nodent.Thenable.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.Thenable.prototype.reject">
            function <span class="apidocSignatureSpan">nodent.Thenable.prototype.</span>reject
            <span class="apidocSignatureSpan">(reason)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.Thenable.prototype.resolve">
            function <span class="apidocSignatureSpan">nodent.Thenable.prototype.</span>resolve
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.Thenable.prototype.then">
            function <span class="apidocSignatureSpan">nodent.Thenable.prototype.</span>then
            <span class="apidocSignatureSpan">(onF, onR)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nodent.arboriculture">module nodent.arboriculture</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.arboriculture.asynchronize">
            function <span class="apidocSignatureSpan">nodent.arboriculture.</span>asynchronize
            <span class="apidocSignatureSpan">(pr, __sourceMapping, opts, logger)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.arboriculture.babelLiteralNode">
            function <span class="apidocSignatureSpan">nodent.arboriculture.</span>babelLiteralNode
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.arboriculture.printNode">
            function <span class="apidocSignatureSpan">nodent.arboriculture.</span>printNode
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nodent.map">module nodent.map</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.map.map">
            function <span class="apidocSignatureSpan">nodent.</span>map
            <span class="apidocSignatureSpan">(nodent, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.map.MapError">
            function <span class="apidocSignatureSpan">nodent.map.</span>MapError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nodent.parser">module nodent.parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.parser.parse">
            function <span class="apidocSignatureSpan">nodent.parser.</span>parse
            <span class="apidocSignatureSpan">(code, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.parser.part">
            function <span class="apidocSignatureSpan">nodent.parser.</span>part
            <span class="apidocSignatureSpan">(code, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nodent.parser.treeWalker">
            function <span class="apidocSignatureSpan">nodent.parser.</span>treeWalker
            <span class="apidocSignatureSpan">(n, walker, state)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nodent.runtime">module nodent.runtime</a><ol>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nodent" id="apidoc.module.nodent">module nodent</a></h1>


    <h2>
        <a href="#apidoc.element.nodent.nodent" id="apidoc.element.nodent.nodent">
        function <span class="apidocSignatureSpan"></span>nodent
        <span class="apidocSignatureSpan">(initOpts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initialize(initOpts){
	// Validate the options
<span class="apidocCodeCommentSpan">/* initOpts:{
 * 		log:function(msg),
 * 		augmentObject:boolean,
 * 		extension:string?
 * 		dontMapStackTraces:boolean
 */
</span>	if (!initOpts)
		initOpts = {} ;
	else {
		// Throw an error for any options we don't know about
		for (var k in initOpts) {
			if (k==="use")
				continue ; // deprecated
			if (!config.hasOwnProperty(k))
				throw new Error("NoDent: unknown option: "+k+"="+JSON.stringify(initOpts[k])) ;
		}
	}


	if (compiler) {
		compiler.setOptions(initOpts);
	} else {
		// Fill in any missing options with their default values
		Object.keys(config).forEach(function(k){
			if (!(k in initOpts))
				initOpts[k] = config[k] ;
		}) ;
		compiler = new NodentCompiler(initOpts) ;
	}

	// If anyone wants to mapStackTraces, do it. The augmentation does not depend on the config options
	if (!initOpts.dontMapStackTraces) {
		// This function is part of the V8 stack trace API, for more info see:
		// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi
		Error.prepareStackTrace = prepareMappedStackTrace ;
	}

	setGlobalEnvironment(initOpts) ;

	/* If we've not done it before, create a compiler for '.js' scripts */
	// Create a new compiler

	var nodentLoaders = [];
	function compareSemVer(a,b) {
		a = a.split('.') ;
		b = b.split('.') ;
		for (var i=0;i&lt;3;i++) {
			if (a[i]&lt;b[i]) return -1 ;
			if (a[i]&gt;b[i]) return 1 ;
		}
		return 0 ;
	}

    function versionAwareNodentJSLoader(mod,filename) {
        if (filename.match(/nodent\/nodent\.js$/)) {
            var downLevel = {path:filename.replace(/\/node_modules\/nodent\/nodent\.js$/,"")} ;
            if (downLevel.path) {
                downLevel.version = JSON.parse(fs.readFileSync(filename.replace(/nodent\.js$/,"package.json"))).version ;
                // Load the specified nodent
                stdJSLoader(mod,filename) ;

                // If the version of nodent we've just loaded is lower than the
                // current (version-aware) version, hook the initialzer
                // so we can replace the JS loader after it's been run.
                if (compareSemVer(downLevel.version,NodentCompiler.prototype.version)&lt;0) {
                    downLevel.originalNodentLoader = mod.exports ;
                    mod.exports = function(){
                        var previousJSLoader = require.extensions['.js'] ;
                        var defaultNodentInstance = downLevel.originalNodentLoader.apply(this,arguments) ;
                        downLevel.jsCompiler = require.extensions['.js'] ;
                        require.extensions['.js'] = previousJSLoader ;
                        setGlobalEnvironment(initOpts) ;
                        return defaultNodentInstance ;
                    } ;
                    Object.keys(downLevel.originalNodentLoader).forEach(function(k){
                        mod.exports[k] = downLevel.originalNodentLoader[k] ;
                    }) ;
                    nodentLoaders.push(downLevel) ;
                    nodentLoaders = nodentLoaders.sort(function(a,b){
                        return b.path.length - a.path.length ;
                    }) ;
                }
            }
        } else if (filename.match(/node_modules\/nodent\/.*\.js$/)) {
            // Things inside nodent always use the standard loader
            return stdJSLoader(mod,filename) ;
        } else {
            // The the appropriate loader for this file
            for (var n=0; n&lt;nodentLoaders.length; n++) {
                if (filename.slice(0,nodentLoaders[n].path.length)==nodentLoaders[n].path) {
                    //console.log("Using nodent@",nodentLoaders[n].version,"to load",filename) ;
                    if (!nodentLoaders[n].jsCompiler) {
                        // The client app loaded, but never initialised nodent (so it can only
                        // be using library/runtime functions, not the require-hook compiler)
                        return stdJSLoader(mod,filename) ;
                    } else {
                        if (nodentLoaders[n].jsCompiler === versi ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nodent.EagerThenable" id="apidoc.element.nodent.EagerThenable">
        function <span class="apidocSignatureSpan">nodent.</span>EagerThenable
        <span class="apidocSignatureSpan">(tick)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">EagerThenable = function (tick){ tick = tick || (typeof process==="object" &amp;&amp; process.nextTick) || (typeof setImmediate==="function" &amp;&amp; setImmediate
) || function(f){setTimeout(f,0)}; var soon = (function () { var fq = [], fqStart = 0, bufferSize = 1024; function callQueue() {
while (fq.length - fqStart) { try { fq[fqStart]() } catch(ex) { } fq[fqStart++] = undefined; if (fqStart === bufferSize) { fq.splice
(0, bufferSize); fqStart = 0; } } } return function (fn) { fq.push(fn); if (fq.length - fqStart === 1) tick(callQueue); }; })();
function Zousan(func) { if (func) { var me = this; func(function (arg) { me.resolve(arg); }, function (arg) { me.reject(arg); }); } }
Zousan.prototype = { resolve: function (value) { if (this.state !== undefined) return; if (value === this) return this.reject(new
 TypeError("Attempt to resolve promise with self")); var me = this; if (value &amp;&amp; (typeof value === "function" || typeof value === "
object")) { try { var first = 0; var then = value.then; if (typeof then === "function") { then.call(value, function (ra) { if (!
first++) { me.resolve(ra); } }, function (rr) { if (!first++) { me.reject(rr); } }); return; } } catch (e) { if (!first) this.reject
(e); return; } } this.state = STATE_FULFILLED; this.v = value; if (me.c) soon(function () { for (var n = 0, l = me.c.length;n &lt;
l; n++) STATE_FULFILLED(me.c[n], value); }); }, reject: function (reason) { if (this.state !== undefined) return; this.state = STATE_REJECTED
; this.v = reason; var clients = this.c; if (clients) soon(function () { for (var n = 0, l = clients.length;n &lt; l; n++) STATE_REJECTED
(clients[n], reason); }); }, then: function (onF, onR) { var p = new Zousan(); var client = { y: onF, n: onR, p: p }; if (this.state
 === undefined) { if (this.c) this.c.push(client); else this.c = [client]; } else { var s = this.state, a = this.v; soon(function
 () { s(client, a); }); } return p; } }; function STATE_FULFILLED(c, arg) { if (typeof c.y === "function") { try { var yret = c.
y.call(undefined, arg); c.p.resolve(yret); } catch (err) { c.p.reject(err); } } else c.p.resolve(arg); } function STATE_REJECTED
(c, reason) { if (typeof c.n === "function") { try { var yret = c.n.call(undefined, reason); c.p.resolve(yret); } catch (err) {
c.p.reject(err); } } else c.p.reject(reason); } Zousan.resolve = function (val) { if (val &amp;&amp; (val instanceof Zousan)) return val
 ; var z = new Zousan(); z.resolve(val); return z; }; Zousan.reject = function (err) { if (err &amp;&amp; (err instanceof Zousan)) return
 err ; var z = new Zousan(); z.reject(err); return z; }; Zousan.version = "2.3.3-nodent" ; return Zousan ; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

#### Shipping a self-contained app to a browser, Node &lt;=0.10.x or other unknown environment
`use nodent-es7` - it's the most compatible as it doesn't require any platform support such as Promises or Generators,
and works on a wide range of desktop and mobile browsers.

#### Shipping an app or module within Node, npm or [modern browsers supporting Promises](http://kangax.github.io/compat-table/es6
/#test-Promise)
`use nodent-promises` provides the most compatibility between modules and apps. If your module or library targets Node earlier than
 v4.1.x, you should install a Promise library (e.g. rsvp, when, bluebird) or use `nodent.Thenable` to expose the Promise API. In
 promises mode, there is no need for a runtime at all. Specifying the option `use nodent-promises {"noRuntime":true}`
will generate pure ES5 code at the cost of some loss in performance and increase in code size.

&gt; **v2.x** users: `nodent.<span class="apidocCodeKeywordSpan">EagerThenable</span>()` is still defined, but as of v3 is the
 same as the `Thenable` implementation.

#### Generators
`use nodent-generators` generates code which is reasonably easy to follow, but is best not used for anything beyond experimentation
 as it requires an advanced browser on the client-side, or Node v4.x.x. The performance and memory overhead of generators is poor
 - currently (Node v6.6.0) averaging 3.5 times slower compared to the es7 with 'lazyThenables'.

#### Engine
`use nodent-engine` does _not_ transpile standard ES7 async/await constructs, but only transpiles the additional non-standard features
 provided by nodent - await anywhere, async getters, async return and throw. At the time of writing, not many runtimes implement
 async and await - Chrome v53 does with command line flags, and Edge 14 are examples. On Chrome, performance is better than generators
, but not quite as good as Promises, and still less than half the speed of ES7 mode. In promises mode, there is no need for a runtime
 at all. Specifying the option `use nodent-engine {"noRuntime":true}` will generate pure ES5 code at the cost of some
loss in performance and increase in code size.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nodent.Thenable" id="apidoc.element.nodent.Thenable">
        function <span class="apidocSignatureSpan">nodent.</span>Thenable
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Zousan(func) { if (func) { var me = this; func(function (arg) { me.resolve(arg); }, function (arg) { me.reject(arg); }); } }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nodent.asyncify" id="apidoc.element.nodent.asyncify">
        function <span class="apidocSignatureSpan">nodent.</span>asyncify
        <span class="apidocSignatureSpan">(promiseProvider)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(promiseProvider) {
	promiseProvider = promiseProvider || Thenable ;
	return function(obj,filter,suffix) {
		if (Array.isArray(filter)) {
			var names = filter ;
			filter = function(k,o) {
				return names.indexOf(k)&gt;=0 ;
			}
		} else {
			filter = filter || function(k,o) {
				return (!k.match(/Sync$/) || !(k.replace(/Sync$/,"") in o)) ;
			};
		}

		if (!suffix)
			suffix = "" ;

		var o = Object.create(obj) ;
		for (var j in o) (function(){
			var k = j ;
			try {
				if (typeof obj[k]==='function' &amp;&amp; (!o[k+suffix] || !o[k+suffix].isAsync) &amp;&amp; filter(k,o)) {
					o[k+suffix] = function() {
						var a = Array.prototype.slice.call(arguments) ;
						var resolver = function($return,$error) {
							var cb = function(err,ok){
								if (err)
									return $error(err) ;
								switch (arguments.length) {
								case 0: return $return() ;
								case 2: return $return(ok) ;
								default: return $return(Array.prototype.slice.call(arguments,1)) ;
								}
							} ;
							// If more args were supplied than declared, push the CB
							if (a.length &gt; obj[k].length) {
								a.push(cb) ;
							} else {
								// Assume the CB is the final arg
								a[obj[k].length-1] = cb ;
							}
							var ret = obj[k].apply(obj,a) ;
						} ;
						return new promiseProvider(resolver) ;
					}
					o[k+suffix].isAsync = true ;
				}
			} catch (ex) {
				// Log the fact that we couldn't augment this member??
			}
		})() ;
		o["super"] = obj ;
		return o ;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	var nodent = require('nodent')(options);

Options:

| Member             | Type   |                        |
|--------------------|--------|------------------------|
| dontMapStackTraces |boolean | default: false
| augmentObject      |boolean | Adds `asyncify(PromiseProvider)` and `isThenable()` to Object.prototype, making expressions such
 as `var client = new DB().<span class="apidocCodeKeywordSpan">asyncify</span>(Promise)` and `if (abc.isThenable()) await abc()`
less verbose
| extension          | string | extension for files to be compiled (default: '.njs'). Note that this is unused if the
file has a `use nodent-` directive.
| log(msg)           |function| Called when nodent has a warning or similar to show. By default they are passed to console.warn().
Set this member to change how to record logging, or to `false` to disable logging.

&gt; **v2.x** The flag 'asyncStackTrace' has been removed as modern debuggers can do this better than nodent can. You
 can specify it, but it is ignored.

Return: a 'nodent' compiler object with the following properties:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nodent.map" id="apidoc.element.nodent.map">
        function <span class="apidocSignatureSpan">nodent.</span>map
        <span class="apidocSignatureSpan">(nodent, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (nodent, opts) {
    if (!opts) opts = {} ;
    if (!opts.Promise)
        opts.Promise = global.Promise || nodent.Thenable ;

	function map(what,result,asyncFn) {
		var hasError = false ;
		if (typeof what=="number") {
			var period = [] ;
			period.length = Math.floor(what) ;
			period.forEach = function(fn) {
				for (var i=0; i&lt;period.length; i++)
					fn.apply(null,[i,i,period]) ;
			} ;
			return map(period,result,asyncFn) ;
		}

		var isArray = Array.isArray(what) ;
		var context = new MapError() ;
		if (!asyncFn &amp;&amp; (typeof result in {'function':true,'undefined':true})) {
			asyncFn = result ;
			result = isArray?[]:{} ;
		}
		var array = isArray?what:Object.keys(what) ;
		return new (opts.Promise)(function ($return,$error) {
			var len = array.length ;
			if (len==0)
				return $return(result) ;

			array.forEach(function(e,i,ar){
				function complete(r) {
					if (r instanceof Object &amp;&amp; typeof r.then==="function")
						return r.then(complete,completeError) ;
					
					var k = isArray?i:e ;
					if (k in result) {
						context.message = "nodent.map: multiple $returns/errors at "+k ;
						return $error(context) ;
					}
					result[k] = r ;
					len -= 1 ;
					if (len==0) {
						if (hasError) {
							context.message = Object.keys(hasError).map(function(e){ return e+": "+hasError[e].message }).join(", ");	
							context.results = result ;
							return $error(context) ;
						}
						return $return(result) ;
					}
					else if (len&lt;0) {
						context.message = "nodent.map: Excess $returns/errors at "+k ;
						return $error(context) ;
					}
				} ;
				function completeError(x) {
					if (!(x instanceof Error))
						x = new Error(x) ;
					if (opts.throwOnError) {
						hasError = hasError || {} ;
						hasError[isArray?i:e] = x ;
					}
					complete(x) ;
				}
				
				if (asyncFn) {
					asyncFn.apply(this,arguments).then(complete,completeError);	
				} else {
					var f = isArray?e:what[e] ;
					if (nodent.isThenable(f))
						f.then(complete,completeError);
					else
						complete(f) ;
				}
			}) ;
		});
	}
	map.MapError = MapError ;
	return map ;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					+ desc.substring(0,desc.length-1)
					+ " =&gt; \u2026"+position.source+":"+position.line+":"+position.column
					+ (frame.getFunctionName()?")":"");
			}
		}
		return '\n    at '+frame;
	}
	return error + stack.<span class="apidocCodeKeywordSpan">map</span>(mappedTrace).join('');
}

// Set the 'global' references to the (backward-compatible) versions
// required by the current version of Nodent
function setGlobalEnvironment(initOpts) {
	var codeGenOpts = defaultCodeGenOpts ;
	/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nodent.setCompileOptions" id="apidoc.element.nodent.setCompileOptions">
        function <span class="apidocSignatureSpan">nodent.</span>setCompileOptions
        <span class="apidocSignatureSpan">(set, compiler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setCompileOptions = function (set, compiler) {
	optionSet[set] = optionSet[set] || copyObj([defaultCodeGenOpts]);
	compiler &amp;&amp; Object.keys(compiler).forEach(function(k){
		if (!(k in defaultCodeGenOpts))
			throw new Error("NoDent: unknown compiler option: "+k) ;
		optionSet[set][k] = compiler[k] ;
	}) ;
	return initialize ;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nodent.setDefaultCompileOptions" id="apidoc.element.nodent.setDefaultCompileOptions">
        function <span class="apidocSignatureSpan">nodent.</span>setDefaultCompileOptions
        <span class="apidocSignatureSpan">(compiler, env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDefaultCompileOptions = function (compiler, env) {
	if (compiler) {
		Object.keys(compiler).forEach(function(k){
			if (!(k in defaultCodeGenOpts))
				throw new Error("NoDent: unknown compiler option: "+k) ;
			defaultCodeGenOpts[k] = compiler[k] ;
		}) ;
	}

	env &amp;&amp; Object.keys(env).forEach(function(k){
		if (!(k in env))
			throw new Error("NoDent: unknown configuration option: "+k) ;
		config[k] = env[k] ;
	}) ;
	return initialize ;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
|-------|-----|------------------------|
|Thenable			|function|Nodent's built in Promise/A+ implementation|
|asyncify			|object|Method to transform methods from callbacks to async functions by wrapping in Promises|
|setDefaultCompileOptions (compiler[,env])|function|Set the defaults for the compiler and environment. This should be called before
 the first compiler is created. The default environment options (`log augmentObject extension dontMapStackTraces asyncStackTrace
`) will be used when the corresponding option is missing when the compiler is created. The compiler options (`sourcemap` and default
 symbol names) must be set before the first compiler is created. The other compilation options (`es7 promises generators engine`)
are set by the corresponding directive|
|setCompileOptions (name,compiler)|function|Set the compilation options for a named [directive](#advanced-configuration) for the
 compiler. This should be called before the first compiler is created.

	// Turn off sourcemap generation:
	nodentMeta.<span class="apidocCodeKeywordSpan">setDefaultCompileOptions</span>({sourcemap:false},{asyncStackTrace:true})

	// Access values that are global to all nodent compiler instances
	var Promise = global.Promise || nodentMeta.Thenable ;	// Set a Promise provider for this module
	nodentMeta.asyncify

You still need to (at least once) create the compiler:
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nodent.Thenable" id="apidoc.module.nodent.Thenable">module nodent.Thenable</a></h1>


    <h2>
        <a href="#apidoc.element.nodent.Thenable.Thenable" id="apidoc.element.nodent.Thenable.Thenable">
        function <span class="apidocSignatureSpan">nodent.</span>Thenable
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Zousan(func) { if (func) { var me = this; func(function (arg) { me.resolve(arg); }, function (arg) { me.reject(arg); }); } }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nodent.Thenable.reject" id="apidoc.element.nodent.Thenable.reject">
        function <span class="apidocSignatureSpan">nodent.Thenable.</span>reject
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (err) { if (err &amp;&amp; (err instanceof Zousan)) return err ; var z = new Zousan(); z.reject(err); return z; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nodent.Thenable.resolve" id="apidoc.element.nodent.Thenable.resolve">
        function <span class="apidocSignatureSpan">nodent.Thenable.</span>resolve
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function (val) { if (val &amp;&amp; (val instanceof Zousan)) return val ; var z = new Zousan(); z.resolve(val); return z; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

In this case, the expression will need wrapping before it is awaited on by Nodent. You can emulate this behaviour by specifying
the code-generation flag 'wrapAwait' in your package.json or after the nodent directive:

		'use nodent {"wrapAwait":true}';

Wrapping every value in a Promise increases the time taken to invoke an async function by about 20%. An alternative to wrapping
everything is to only wrap expression where this might be the case explicitly:

		var x = await Promise.<span class="apidocCodeKeywordSpan">resolve</span>(maybeThisIsAPromise()) ;

or

		var isThenable = require('nodent').isThenable ;
			...
	var x = maybeThisIsAPromise() ;
	if (isThenable(x))
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nodent.Thenable.prototype" id="apidoc.module.nodent.Thenable.prototype">module nodent.Thenable.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.nodent.Thenable.prototype.reject" id="apidoc.element.nodent.Thenable.prototype.reject">
        function <span class="apidocSignatureSpan">nodent.Thenable.prototype.</span>reject
        <span class="apidocSignatureSpan">(reason)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (reason) { if (this.state !== undefined) return; this.state = STATE_REJECTED; this.v = reason; var clients = this.c; if
 (clients) soon(function () { for (var n = 0, l = clients.length;n &lt; l; n++) STATE_REJECTED(clients[n], reason); }); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nodent.Thenable.prototype.resolve" id="apidoc.element.nodent.Thenable.prototype.resolve">
        function <span class="apidocSignatureSpan">nodent.Thenable.prototype.</span>resolve
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function (value) { if (this.state !== undefined) return; if (value === this) return this.reject(new TypeError("Attempt to resolve
 promise with self")); var me = this; if (value &amp;&amp; (typeof value === "function" || typeof value === "object")) { try { var first
 = 0; var then = value.then; if (typeof then === "function") { then.call(value, function (ra) { if (!first++) { me.resolve(ra); } },
function (rr) { if (!first++) { me.reject(rr); } }); return; } } catch (e) { if (!first) this.reject(e); return; } } this.state =
STATE_FULFILLED; this.v = value; if (me.c) soon(function () { for (var n = 0, l = me.c.length;n &lt; l; n++) STATE_FULFILLED(me.c[n
], value); }); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

In this case, the expression will need wrapping before it is awaited on by Nodent. You can emulate this behaviour by specifying
the code-generation flag 'wrapAwait' in your package.json or after the nodent directive:

		'use nodent {"wrapAwait":true}';

Wrapping every value in a Promise increases the time taken to invoke an async function by about 20%. An alternative to wrapping
everything is to only wrap expression where this might be the case explicitly:

		var x = await Promise.<span class="apidocCodeKeywordSpan">resolve</span>(maybeThisIsAPromise()) ;

or

		var isThenable = require('nodent').isThenable ;
			...
	var x = maybeThisIsAPromise() ;
	if (isThenable(x))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nodent.Thenable.prototype.then" id="apidoc.element.nodent.Thenable.prototype.then">
        function <span class="apidocSignatureSpan">nodent.Thenable.prototype.</span>then
        <span class="apidocSignatureSpan">(onF, onR)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">then = function (onF, onR) { var p = new Zousan(); var client = { y: onF, n: onR, p: p }; if (this.state === undefined) { if (this.c) this
.c.push(client); else this.c = [client]; } else { var s = this.state, a = this.v; soon(function () { s(client, a); }); } return
p; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...

* **lazyThenables**

&gt; **v2.x** users - lazyThenables are _only_ available in -es7 mode in v3, and the nodent.Thenable implementation is _not_ lazy
, as it was in v2.x.

Invoking an async function _without_ a preceding `await` (simply by calling it) executes the function body but you can't get
 the result. This is useful for initiating 'background' things, or running async functions for their side effects. This
 is in compliance with the ES7 specification.

However, this has a performance overhead. For maximum performance, you can specify this code generation option in `use nodent-es7
 {"lazyThenables":true}` mode. In this mode, if you call the async function the body _is not actually executed_ until
resolved with an `await` (or a `.<span class="apidocCodeKeywordSpan">then</span>()`). If you know your code always uses `await`,
you can use this option to improve performance.

In `use nodent-promises` mode, it is the implementation of the Promise that determines the execution scheduling and performance.
The table below is a summary of modes and execution semantics. You can test the performance on your own hardware with the following
 command. Note the relative performance is a worst case, since the test does nothing other than make async calls in a loop.

		./nodent.js tests tests/semantics/perf.js

| Mode  	 | Flags / Implementation 	| Lazy / Eager  | Possibly sync resolution  | Performance (relative) |
|------------|--------------------------|---------------|---------------------------|------------------------|
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nodent.arboriculture" id="apidoc.module.nodent.arboriculture">module nodent.arboriculture</a></h1>


    <h2>
        <a href="#apidoc.element.nodent.arboriculture.asynchronize" id="apidoc.element.nodent.arboriculture.asynchronize">
        function <span class="apidocSignatureSpan">nodent.arboriculture.</span>asynchronize
        <span class="apidocSignatureSpan">(pr, __sourceMapping, opts, logger)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asynchronize = function (pr, __sourceMapping, opts, logger) {
    try {
        return asynchronize(pr, __sourceMapping, opts, logger);
    } catch (ex) {
        if (ex instanceof SyntaxError) {
            var l = pr.origCode.substr(ex.pos - ex.loc.column);
            l = l.split("\n")[0];
            ex.message += " (nodent)\n" + l + "\n" + l.replace(/[\S ]/g, "-").substring(0, ex.loc.column) + "^";
            ex.stack = "";
        }
        throw ex;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function compileNodentedFile(nodent,log) {
    log = log || nodent.log ;
	return function(mod, filename, parseOpts) {
		var content = stripBOM(fs.readFileSync(filename, 'utf8'));
		var pr = nodent.parse(content,filename,parseOpts);
		parseOpts = parseOpts || parseCompilerOptions(pr.ast,log, filename) ;
		nodent.<span class="apidocCodeKeywordSpan">asynchronize</span>(pr,undefined,parseOpts,log) ;
		nodent.prettyPrint(pr,parseOpts) ;
		mod._compile(pr.code, pr.filename);
	}
};

// Things that DON'T depend on initOpts (or config, and therefore nodent)
function asyncify(promiseProvider) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nodent.arboriculture.babelLiteralNode" id="apidoc.element.nodent.arboriculture.babelLiteralNode">
        function <span class="apidocSignatureSpan">nodent.arboriculture.</span>babelLiteralNode
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function babelLiteralNode(value) {
    if (value === null)
        return {
        type: 'NullLiteral',
        value: null,
        raw: 'null'
    };
    if (value === true || value === false)
        return {
        type: 'BooleanLiteral',
        value: value,
        raw: JSON.stringify(value)
    };
    if (value instanceof RegExp) {
        var str = value.toString();
        var parts = str.split('/');
        return {
            type: 'RegExpLiteral',
            value: value,
            raw: str,
            pattern: parts[1],
            flags: parts[2]
        };
    }
    if (typeof value === 'number')
        return {
        type: 'NumericLiteral',
        value: value,
        raw: JSON.stringify(value)
    };
    return {
        type: 'StringLiteral',
        value: value,
        raw: JSON.stringify(value)
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	var r = { origCode:code.toString(), filename:origFilename } ;
	try {
		r.ast = parser.parse(r.origCode, opts &amp;&amp; opts.parser) ;
		if (opts.babelTree) {
			parser.treeWalker(r.ast,function(node,descend,path){
				if (node.type==='Literal')
					path[0].replace(treeSurgeon.<span class="apidocCodeKeywordSpan">babelLiteralNode</span>(node.value)) ;
				else if (node.type==='Property') {
				    // Class/ObjectProperty in babel6
				    if (path[0].parent.type==='ClassBody'){
				        // There's no easy mapping here as it appears to be borderline in the specification?
				        // It's definitely a kind of ClassProperty tho....
                        node.type = 'ClassProperty' ;
				    } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nodent.arboriculture.printNode" id="apidoc.element.nodent.arboriculture.printNode">
        function <span class="apidocSignatureSpan">nodent.arboriculture.</span>printNode
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function printNode(n) {
    if (!n) return '' ;
    if (Array.isArray(n))
        return n.map(printNode).join("|\n");
    try {
        return outputCode(n) ; //+"\t//@"+Object.keys(n).filter(function(k){ return k[0]==='$'}).map(function(k){ return k+":"+n
[k] });
    } catch (ex) {
        return ex.message + ": " + (n &amp;&amp; n.type);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nodent.map" id="apidoc.module.nodent.map">module nodent.map</a></h1>


    <h2>
        <a href="#apidoc.element.nodent.map.map" id="apidoc.element.nodent.map.map">
        function <span class="apidocSignatureSpan">nodent.</span>map
        <span class="apidocSignatureSpan">(nodent, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (nodent, opts) {
    if (!opts) opts = {} ;
    if (!opts.Promise)
        opts.Promise = global.Promise || nodent.Thenable ;

	function map(what,result,asyncFn) {
		var hasError = false ;
		if (typeof what=="number") {
			var period = [] ;
			period.length = Math.floor(what) ;
			period.forEach = function(fn) {
				for (var i=0; i&lt;period.length; i++)
					fn.apply(null,[i,i,period]) ;
			} ;
			return map(period,result,asyncFn) ;
		}

		var isArray = Array.isArray(what) ;
		var context = new MapError() ;
		if (!asyncFn &amp;&amp; (typeof result in {'function':true,'undefined':true})) {
			asyncFn = result ;
			result = isArray?[]:{} ;
		}
		var array = isArray?what:Object.keys(what) ;
		return new (opts.Promise)(function ($return,$error) {
			var len = array.length ;
			if (len==0)
				return $return(result) ;

			array.forEach(function(e,i,ar){
				function complete(r) {
					if (r instanceof Object &amp;&amp; typeof r.then==="function")
						return r.then(complete,completeError) ;
					
					var k = isArray?i:e ;
					if (k in result) {
						context.message = "nodent.map: multiple $returns/errors at "+k ;
						return $error(context) ;
					}
					result[k] = r ;
					len -= 1 ;
					if (len==0) {
						if (hasError) {
							context.message = Object.keys(hasError).map(function(e){ return e+": "+hasError[e].message }).join(", ");	
							context.results = result ;
							return $error(context) ;
						}
						return $return(result) ;
					}
					else if (len&lt;0) {
						context.message = "nodent.map: Excess $returns/errors at "+k ;
						return $error(context) ;
					}
				} ;
				function completeError(x) {
					if (!(x instanceof Error))
						x = new Error(x) ;
					if (opts.throwOnError) {
						hasError = hasError || {} ;
						hasError[isArray?i:e] = x ;
					}
					complete(x) ;
				}
				
				if (asyncFn) {
					asyncFn.apply(this,arguments).then(complete,completeError);	
				} else {
					var f = isArray?e:what[e] ;
					if (nodent.isThenable(f))
						f.then(complete,completeError);
					else
						complete(f) ;
				}
			}) ;
		});
	}
	map.MapError = MapError ;
	return map ;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
					+ desc.substring(0,desc.length-1)
					+ " =&gt; \u2026"+position.source+":"+position.line+":"+position.column
					+ (frame.getFunctionName()?")":"");
			}
		}
		return '\n    at '+frame;
	}
	return error + stack.<span class="apidocCodeKeywordSpan">map</span>(mappedTrace).join('');
}

// Set the 'global' references to the (backward-compatible) versions
// required by the current version of Nodent
function setGlobalEnvironment(initOpts) {
	var codeGenOpts = defaultCodeGenOpts ;
	/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nodent.map.MapError" id="apidoc.element.nodent.map.MapError">
        function <span class="apidocSignatureSpan">nodent.map.</span>MapError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MapError(message) {
  Error.apply(this,arguments) ;
  this.name = 'MapError';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nodent.parser" id="apidoc.module.nodent.parser">module nodent.parser</a></h1>


    <h2>
        <a href="#apidoc.element.nodent.parser.parse" id="apidoc.element.nodent.parser.parse">
        function <span class="apidocSignatureSpan">nodent.parser.</span>parse
        <span class="apidocSignatureSpan">(code, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acornParse(code, config) {
    var comments = [] ;
    var options = {
        ecmaVersion:8,
        allowHashBang:true,
        allowReturnOutsideFunction:true,
        allowImportExportEverywhere:true,
        locations:true,
        onComment:comments
    } ;

    if (!(config &amp;&amp; config.noNodentExtensions) || parseInt(acorn.version) &lt; 4) {
        if (!alreadyInstalledPlugin) {
            if (parseInt(acorn.version) &lt; 4)
                console.warn("Nodent: Warning - noNodentExtensions option requires acorn &gt;=v4.x. Extensions installed.") ;
            require('acorn-es7-plugin')(acorn) ;
            alreadyInstalledPlugin = true ;
        }
        options.plugins = options.plugins || {} ;
        options.plugins.asyncawait = {asyncExits:true, awaitAnywhere:true} ;
    }

    if (config)
        for (var k in config)
            if (k !== 'noNodentExtensions')
                options[k] = config[k] ;

    var ast = acorn.parse(code,options) ;

    // attach comments to the most tightly containing node
    treeWalker(ast,function(node,descend,path){
        descend() ;
        while (comments.length &amp;&amp; node.loc &amp;&amp;
            (node.loc.start.line &gt;= comments[0].loc.start.line &amp;&amp; node.loc.end.line&gt;=comments[0].loc.end.line)) {
            node.$comments = node.$comments||[] ;
            node.$comments.push(comments.shift()) ;
        }
    }) ;
    return ast ;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	            filename = require('path').dirname(filename) ;

	        var packagePath = require('resolve').sync('package.json',{
	            moduleDirectory:[''],
	            extensions:[''],
	            basedir:filename
	        }) ;
	        var packageOptions = JSON.<span class="apidocCodeKeywordSpan">parse</span>(fs.readFileSync(packagePath)).nodent.directive
[set] ;
	    } catch(ex) {
	        // Meh
	    }
	}
	try {
		parseOpts = copyObj([optionSets[set],packageOptions,regex[2] &amp;&amp; JSON.parse(regex[2])]);
	} catch(ex) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nodent.parser.part" id="apidoc.element.nodent.parser.part">
        function <span class="apidocSignatureSpan">nodent.parser.</span>part
        <span class="apidocSignatureSpan">(code, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function partialParse(code, args) {
  if (!parseCache[code]) {
    parseCache[code] = acornParse(code,{
      noNodentExtensions:true, // The partial parser only ever parses ES5
      locations:false,
      ranges:false,
      onComment:null
    }) ;
  }

  var result = substitute(parseCache[code]) ;
  return {body:result.body, expr:result.body[0].type==='ExpressionStatement' ? result.body[0].expression : null} ;

<span class="apidocCodeCommentSpan">  /* parse and substitute:
   *
   *    $1      Substitute the specified expression. If $1 occupies a slot which is an array of expressions (e.g arguments, params
)
   *            and the passed argument is an array, subtitute the whole set
   *    {$:1}   Substitute a single statement
   *
   */
</span>  function substitute(src,dest) {
    if (Array.isArray(dest) &amp;&amp; !Array.isArray(src))
        throw new Error("Can't substitute an array for a node") ;

    dest = dest || {} ;
    Object.keys(src).forEach(function(k){
      if (!(src[k] instanceof Object))
          return dest[k] = src[k] ;

      function moreNodes(v){ if (typeof v==="function") v = v() ; dest = dest.concat(v) ; return dest };
      function copyNode(v){ if (typeof v==="function") v = v() ; dest[k] = v ; return dest };

      // The src is an array, so create/grow the destination
      // It could an an array of expressions $1,$2,$3 or statements $:1;$:2;$:3;
      if (Array.isArray(src[k]))
          return dest[k] = substitute(src[k],[]) ;

      var p ;
      if (Array.isArray(dest))
          p = moreNodes ;
      else
          p = copyNode ;

      // Substitute a single identifier $.. with an expression (TODO: test provided arg is an expression node)
      if (src[k].type==='Identifier' &amp;&amp; src[k].name[0]==='$')
          return p(args[src[k].name.slice(1)]) ;

      // Substitute a single labeled statement $:.. with a statement (TODO: test provided arg is a statement node)
      if (src[k].type === 'LabeledStatement' &amp;&amp; src[k].label.name==='$') {
          var spec = src[k].body.expression ;
          return p(args[spec.name || spec.value]) ;
      }

      // Magic label to set call a function to modify a statement node  $$method: &lt;statement&gt;
      // The newNode = args.method(oldNode)
      if (src[k].type === 'LabeledStatement' &amp;&amp; src[k].label.name.slice(0,2)==='$$') {
          return p(args[src[k].label.name.slice(2)](substitute(src[k]).body)) ;
      }

      return p(substitute(src[k])) ;
    }) ;
    return dest ;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        if (opts.noRuntime) {
if (arg) {
    if (examine(arg).isLiteral) {
        throw new Error("Nodent: 'noRuntime' option only compatible with -promise and -engine modes") ;
    }
    // Add a global synchronous exception handler to (left)
    left.body.body = parser.<span class="apidocCodeKeywordSpan">part</span>("try {$:0} catch($2) {return $1($2)}",[cloneNode
(left.body),arg,ident('$boundEx')]).body ;
} else if (opts.es6target &amp;&amp; !left.id &amp;&amp; left.type.indexOf("Function")===0) {
    left.type = 'ArrowFunctionExpression' ;
    return left ;
}
if (opts.es6target &amp;&amp; !left.id) {
    left.type = 'ArrowFunctionExpression' ;
    return left;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nodent.parser.treeWalker" id="apidoc.element.nodent.parser.treeWalker">
        function <span class="apidocSignatureSpan">nodent.parser.</span>treeWalker
        <span class="apidocSignatureSpan">(n, walker, state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function treeWalker(n, walker, state){
    if (!state) {
        state = [{self:n}] ;
        state.replace = function(pos,newNode) {
            state[pos].replace(newNode) ;
        }
    }

    function goDown(ref) {
        ref.replace = referencePrototypes.replace ;
        ref.append = referencePrototypes.append ;
        if (ref.index) {
            Object.defineProperties(ref, {index:{enumerable:true,get:referencePrototypes.index}}) ;
            ref.remove = referencePrototypes.removeElement ;
        } else {
            ref.remove = referencePrototypes.removeNode ;
        }
        state.unshift(ref) ;
        treeWalker(ref.self,walker,state) ;
        state.shift() ;
    }

    function descend() {
        if (!(n.type in acornBase)) {
            // We don't know what type of node this is - it's not in the ESTree spec,
            // (maybe a 'react' extension?), so just ignore it
        } else {
            acornBase[n.type](n,state,function down(sub,_,derivedFrom){
                if (sub===n)
                    return acornBase[derivedFrom || n.type](n,state,down) ;

                var keys = Object.keys(n) ;
                for (var i=0; i&lt;keys.length; i++){
                    var v = n[keys[i]] ;
                    if (Array.isArray(v)) {
                        if (v.indexOf(sub)&gt;=0) {
                            goDown({
                                self:sub,
                                parent:n,
                                field:keys[i],
                                index:true
                            }) ;
                        }
                    } else if (v instanceof Object &amp;&amp; sub===v) {
                        goDown({
                            self:sub,
                            parent:n,
                            field:keys[i]
                        }) ;
                    }
                }
            }) ;
        }
    } ;
    walker(n,descend,state) ;
    return n ;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	if (typeof __sourceMapping==="object" &amp;&amp; opts===undefined)
		opts = __sourceMapping ;

	var r = { origCode:code.toString(), filename:origFilename } ;
	try {
		r.ast = parser.parse(r.origCode, opts &amp;&amp; opts.parser) ;
		if (opts.babelTree) {
			parser.<span class="apidocCodeKeywordSpan">treeWalker</span>(r.ast,function(node,descend,path){
				if (node.type==='Literal')
					path[0].replace(treeSurgeon.babelLiteralNode(node.value)) ;
				else if (node.type==='Property') {
				    // Class/ObjectProperty in babel6
				    if (path[0].parent.type==='ClassBody'){
				        // There's no easy mapping here as it appears to be borderline in the specification?
				        // It's definitely a kind of ClassProperty tho....
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nodent.runtime" id="apidoc.module.nodent.runtime">module nodent.runtime</a></h1>

</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>